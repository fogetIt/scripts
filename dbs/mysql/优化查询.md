##### 使用索引的缺点
- 减慢增删改数据的速度
- 占用磁盘空间
- 当查询优化器生成执行计划时，会考虑索引，太多的索引会给查询优化器增加工作量，导致无法选择最优的查询。

##### EXPLAIN
- 在一般的SQL语句前加上 EXPLAIN ，可以帮助选择更好的索引和写出更优化的查询语句。
	- id
		- 识别符(查询序列号)
	- select_type
		- 类型
			- simple：简单查询，没有 union 和子查询
			- primary：在有子查询的语句中，最外面的 select
			- union：union 语句后面的 select
			- dependentunion：union 后面的 select，取决于外面的查询
			- unionresult：union 的结果
	- table
		- 表名
	- type
		- 连接的类型(ALL/Range/Ref)，其中ref是最理想的
	- system
		- const 类型的特列，平时不会出现
	- possible_keys
		- 查询可以利用的索引名
	- key
		- 实际使用的索引
	- key_len
		- 索引中被使用部分的长度（字节）
	- ref
		- 显示列名字或者"const"
		- const用于只检索出两条数据的情况下，比较 primarykey 或者 unique 索引
	- rows
		- 显示 MySQL 认为在找到正确结果之前必须扫描的行数
	- extra
		- MySQL的建议
　　
##### 优化查询
- 尽可能使用较短的数据类型
- 尽可能使用定长数据类型(用char代替varchar)
	- 万一出现数据表崩溃，使用固定长度数据行的表更容易重新构造
	- 使用固定长度的数据行，每个记录的开始位置都是固定记录长度的倍数，可以很容易被检测到
	- 对于 MyISAM 类型的数据表，虽然转换成固定长度的数据列可以提高性能，但是占据的空间也大
- 尽量将列定义为 not null ，这样在查询时， MySQL 不需要检查是否存在特例(null 值)，从而优化查询，而且所需的空间更少
- 如果一列只含有有限数目的特定值，应将其转换为 enum 列，因为所有的 enum 值在系统内都是以标识数值来表示的，处理的更快
- 使用 optimize table
	- 对于经常修改的表，容易产生碎片，使在查询数据库时必须读取更多的磁盘块，降低查询性能
	- 具有可变长的表都存在磁盘碎片问题，这个问题对 blob 数据类型更为突出，因为其尺寸变化非常大
	- 可以通过使用optimize table来整理碎片，保证数据库性能不下降，优化那些受碎片影响的数据表
	- optimize table 可以用于 MyISAM 和 BDB 类型的数据表
	- 实际上任何碎片整理方法都是用 mysqldump 来转存数据表，然后使用转存后的文件并重新建数据表
- 使用 procedure analyse() 显示最佳类型的建议
```sql
select * from students procedure analyse();
# 要求建议不要含有少于 16 多于 256 字节的 enum 类型，如果没有限制，输出可能会很长
select * from students procedure analyse(16,256);
```
- 使用查询缓存
	- 查询缓存的工作方式：
		- 第一次执行某条select语句时，服务器记住该查询的文本内容和查询结果，存储在缓存中
		- 下次碰到这个语句时，直接从缓存中返回结果
		- 当更新数据表后，该数据表的任何缓存查询都变成无效的，并且会被丢弃
	- 配置缓存参数：
		- query_cache_type=0
			- 查询缓存的操作模式
				- 0：不缓存
				- 1：缓存查询，除非以 select sql_no_cache 开头
				- 2：根据需要只缓存那些以 select sql_cache 开头的查询
		- query_cache_size
			- 设置查询缓存的最大结果集的大小，比这个值大的不会被缓存
	- 调整硬件
		- 在机器上装更多的内存
		- 增加更快的硬盘以减少 I/O 等待时间
			- 寻道时间是决定性能的主要因素，逐字地移动磁头是最慢的，一旦磁头定位，从磁道读则很快
		- 在不同的物理硬盘设备上重新分配磁盘活动
			- 如果可能，应将最繁忙的数据库存放在不同的物理设备上
			- 这跟使用同一物理设备的不同分区是不同的，因为它们将争用相同的物理资源(磁头)
- 永远用小结果集驱动大结果集
- 当不确定是用哪种类型的 JOIN 时，让 mysql 优化器自动去判断
- 主从库
	- 主库：insert、update
	- 从库：select

##### 创建索引
```sql
ALTER TABLE tb ADD INDEX ind_name (column);
ALTER TABLE tb ADD PRIMARY KEY (column);//建立主键索引
ALTER TABLE tb ADD UNIQUE(column);
ALTER TABLE tb ADD FULLTEXT(column);
ALTER TABLE tb ADD INDEX ind_name (column1,column2,...);//添加多列索引
CREATE INDEX ind_name ON tb (column);
CREATE UNIQUE INDEX ind_name ON tb1 (column);//建立唯一性索引
```
### 删除索引
```sql
DROP INDEX ind_name ON tb;
ALTER TABLE tb DROP INDEX ind_name;
-- 删除主键
alter table tb drop primary key(id);

-- 添加主键
alter table tb add primary key(id);

-- 删除索引
ALTER TABLE tb DROP INDEX good_id;

-- 添加/删除联合主键
ALTER TABLE tb ADD CONSTRAINT pk_name PRIMARY KEY(列名1，列名2)；
ALTER TABLE `test` DROP INDEX `tt`;
```

##### 外键
外键往往在更新子表或者删除子表数据都会去主表判断一下，这是个隐式操作。